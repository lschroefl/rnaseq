---
output: 
    html_document: 
        code_folding: hide
---
<style type="text/css">
.main-container {
  max-width: 1800px;
  margin-left: auto;
  margin-right: auto;
}
</style>
<pre>
</pre>
# Neuronet{.tabset}
<br>
</br>
<font size = "5">For all experimental conditions, the bulk RNA was isolated from 
the mouse brain

+ of **treated** (4Rx) or **untreated** mice
+ from different regions (**penumbra** or **core**) 
+ for different timepoints (**3 days** or **7 days**) 

after **middle cerebral artery occlusion**, then sequenced via Illumina next-generation sequencing. 
The **raw reads** were used for pseudomapping with **salmon**, then subsequently
**DESeq2** was used to infer differential gene expression, adn gene set enrichment 
analysis was performed via **clusteRprofiler**.
</font>
<br>
</br>
<font size = "5">Experimental groups:

 + ctrl - 3 days - penumbra
 + sham - 3 days - penumbra
 + trt(4Rx) - 3 days - penumbra 
 + ctrl - 7 days - penumbra
 + trt(4Rx) - 7 days - penumbra
 + ctrl - 7 days - core
 + trt(4Rx) - 7 days - core 
  
The model for differentially expression is based on the 
**contrast of control to treatment**, ctrl is set as the reference level.</font>
<pre>
</pre>
## Genes technical plots
### DESeq2 model 
```{r RcodeDESeq2, message = FALSE, warning = FALSE, results = FALSE}
# library import 
library("DESeq2")
library("readr")
library("tximport")
library("edgeR")
library("httpgd")
library("tximport")
library("knitr")
library("ggplot2")
library("ggrepel")
library("tidyverse")
library("RColorBrewer")
library("pheatmap")
library("reshape2")
library("vsn")
library("ggvenn")
library("ggpubr")
library("ggplotify")
library("biomaRt")
library("clusterProfiler")
library("org.Mm.eg.db")
library("msigdbr")
library("vissE")
library("msigdb")
library("GSEABase")
library("igraph")
library("patchwork")
library("ggpattern")
library("tm")
library("lessR")
library("gridGraphics")
library("grid")
require("devtools")
library("cowplot")
library("ggwordcloud")
library("stringr")
# size of plots
knitr::opts_chunk$set(fig.width = 12, fig.height = 8)
# loading mapping statistics
stats_star <- read.csv(
    "/projects/neuronet/seq_april/processing/mapping/ensembl/raw/statistics.tsv",
    sep = "\t", header = TRUE, row.names = "ID"
)
stats_hisat2 <- read.csv(
    "/projects/neuronet/neuronet/processing/mapping/statistics.tsv",
    sep = "\t", header = TRUE, row.names = "ID"
)
# loading samples table
samples <- read.table("/projects/neuronet/neuronet/processing/samples_neuronet.csv", sep = ",", header = TRUE)
samples$condition <- as.factor(samples$condition)
samples$timepoint <- as.factor(samples$timepoint)
samples$brainRegion <- as.factor(samples$brainRegion)
samples$fileName <- do.call(paste, c(samples, sep = "-"))
samples$fileName <- str_replace(samples$fileName, "4Rx", "trt")
rownames(samples) <- samples$fileName
# sub table of samples
samplesDay3 <- samples[which(samples$timepoint == "day3"),]
# import of data
tx2gene <- read_csv("/projects/neuronet/neuronet/processing/genAnno/Mus_musculus.GRCm39.110.tx2gene", col_names = FALSE)
quantFiles <- file.path("/projects/neuronet/neuronet/processing/mapping/salmon", samples$fileName, "quant.sf")
all(file.exists(quantFiles))
names(quantFiles) <- samples$fileName
txi <- tximport(quantFiles, type = "salmon", tx2gene = tx2gene)
# subsetting my txi object for different timepoints
txiDay3 <- lapply(txi, function(x) if(is.matrix(x)) return(x[,samples$fileName[which(samples$timepoint == "day3")]]) else return(x))
txiDay7Penumbra <- lapply(txi, function(x) if(is.matrix(x)) return(x[,samples$fileName[which(c(samples$timepoint == "day7" & samples$brainRegion == "ipsiPenumbra"))]]) else return(x))
txiDay7Core <- lapply(txi, function(x) if(is.matrix(x)) return(x[,samples$fileName[which(c(samples$timepoint == "day7" & samples$brainRegion == "ipsiCore"))]]) else return(x))

# DESeq2 model Day 3 --------------------------------------
ddsDay3 <- DESeqDataSetFromTximport(txiDay3, colData = samples[which(samples$timepoint == "day3"),], design = ~condition)
ddsDay3$condition <- relevel(ddsDay3$condition, ref = "ctrl")
ddsDay3_keep <- rowSums(counts(ddsDay3) >= 5) >= 3
ddsDay3 <- ddsDay3[ddsDay3_keep, ]
ddsDay3 <- DESeq(ddsDay3)
# critical value of chi-square distribution, set sig cutoff for wald statistics
qchisq(p = 0.1, df = 9, lower.tail = TRUE)
# results
resultsDay3 <- results(ddsDay3, alpha = 0.1, contrast = c("condition", "4Rx", "ctrl"))
resultsDay3Sham <- results(ddsDay3, alpha = 0.1, contrast = c("condition", "sham", "ctrl"))
# selection specifics sets of results
featureNamesDay3 <- row.names(subset(resultsDay3, padj < 0.1))
featuresDay3 <- subset(resultsDay3, padj < 0.1)
topLfcDay3 <- rbind(
    head(featuresDay3[order(featuresDay3$log2FoldChange, decreasing = TRUE), ], n = 10),
    tail(featuresDay3[order(featuresDay3$log2FoldChange, decreasing = TRUE), ], n = 10)
)
topPadjDay3 <- head(featuresDay3[order(featuresDay3$padj, decreasing = FALSE), ], n = 20)
resultsDay3Na <- resultsDay3[!complete.cases(resultsDay3), ]
resultsDay3NaCounts <- assay(ddsDay3)[rownames(ddsDay3) %in% rownames(resultsDay3Na), ]
# counts ordered
Day3SampleCounts <- as.data.frame(colSums(txiDay3$counts))
Day3GeneCounts <- as.data.frame(rowSums(txiDay3$counts))
names(Day3GeneCounts) <- "counts"
Day3GeneCounts <- Day3GeneCounts[order(Day3GeneCounts$counts, decreasing = TRUE), , drop = FALSE]
# normalizations and transformations
ddsDay3Vst <- vst(ddsDay3, blind = FALSE)
ddsDay3Rlog <- rlog(ddsDay3, blind = TRUE)
ddsDay3Norm <- normTransform(ddsDay3)
ddsDay3Shrink <- lfcShrink(ddsDay3, coef = "condition_4Rx_vs_ctrl", type = "apeglm")
# gene ID map, and additional metadata
# listEnsembl()
ensembl <- useEnsembl(biomart = "genes", version = "109")
datasets <- listDatasets(ensembl)
# datasets
ensembl <- useDataset(dataset = "mmusculus_gene_ensembl", mart = ensembl)
# listFilters(ensembl)
# listAttributes(ensembl)
# AnnotationDbi::keytypes(org.Mm.eg.db) ### KEYTYPES of my database !!!
idMap <- getBM(
    attributes = c("mgi_symbol", "ensembl_gene_id", "entrezgene_id", "chromosome_name", "start_position", "end_position"),
    filters = "mgi_symbol",
    values = as.character(rownames(txi$counts)),
    mart = ensembl
)
idMap$endMinusStart <- abs(idMap$end_position - idMap$start_position)
idMapAmbiguous <- idMap[idMap$mgi_symbol %in% unique(idMap[duplicated(idMap$mgi_symbol), ])$mgi_symbol, ]
resultsDay3Metadata <- merge(
    as.data.frame(resultsDay3),
    idMap,
    by.x = "row.names",
    by.y = "mgi_symbol",
    all.x = TRUE,
    all.y = FALSE
)
featuresDay3Metadata <- merge(
    as.data.frame(featuresDay3),
    idMap,
    by.x = "row.names",
    by.y = "mgi_symbol",
    all.x = TRUE,
    all.y = FALSE
)
rownames(featuresDay3Metadata) <- featuresDay3Metadata$Row.names
featuresDay3Metadata$Row.names <- NULL
# GO Pathways of my significant genes in different levels
featuresGobp1 <- groupGO(
    gene = as.character(featuresDay3Metadata$entrezgene_id),
    OrgDb = "org.Mm.eg.db",
    keyType = "ENTREZID",
    ont = "BP",
    level = 1,
    readable = TRUE
)
featuresGobp2 <- groupGO(
    gene = as.character(featuresDay3Metadata$entrezgene_id),
    OrgDb = "org.Mm.eg.db",
    keyType = "ENTREZID",
    ont = "BP",
    level = 2,
    readable = TRUE
)
featuresGobp3 <- groupGO(
    gene = as.character(featuresDay3Metadata$entrezgene_id),
    OrgDb = "org.Mm.eg.db",
    keyType = "ENTREZID",
    ont = "BP",
    level = 3,
    readable = TRUE
)
featuresGobp4 <- groupGO(
    gene = as.character(featuresDay3Metadata$entrezgene_id),
    OrgDb = "org.Mm.eg.db",
    keyType = "ENTREZID",
    ont = "BP",
    level = 4,
    readable = TRUE
)
```
<pre>



</pre>
### Statistical summary of the DESeq2 result
```{r summary}
summary(resultsDay3)
as.data.frame(featuresDay3)
```
<pre>



</pre>
### Reads assigned to genes
```{r readsAssigned}
pltCounts <- as.data.frame(colSums(txi$counts))
pltCounts$condition <- samples$condition
names(pltCounts)[names(pltCounts) == "colSums(txi$counts)"] <- "counts"
pltCounts_quantiles <- quantile(pltCounts$counts, probs = c(0.05, 0.25, 0.75, 0.95))

ggplot(
    pltCounts,
    aes(x = rownames(pltCounts), y = counts),
    col = condition
) +
    geom_bar(
        aes(fill = condition),
        stat = "identity"
    ) +
    geom_hline(
        yintercept = as.numeric(pltCounts_quantiles),
        color = "red"
    ) +
    geom_label_repel(
        data = data.frame(x = 0, y = as.numeric(pltCounts_quantiles)),
        aes(x = x, y = y, label = names(pltCounts_quantiles))
    ) +
    scale_y_continuous(labels = scales::comma) +
    coord_flip() +
    xlab("sample")
```
<pre>



</pre>
### Proportion of the top 5 mapped features across samples
Piechart showing the number of unmapped reads, ambiguos reads and the proportion of the 5 most highly expressed features across all samples.
```{r MappingInfoTotal}
total_reads <- sum(as.numeric(gsub(",", "", stats_hisat2[grepl("day3", row.names(stats_hisat2)), "reads"])))
total_mapped <- sum(Day3GeneCounts)
top_ten <- Day3GeneCounts[1:6, , drop = FALSE]
unmapped_reads <- total_reads - total_mapped
remaining_mapped <- total_mapped - sum(top_ten)
pltData <- data.frame(
    row.names = c("unmapped reads", "various", row.names(top_ten)),
    values = mapply(c, unmapped_reads, remaining_mapped, top_ten)
)
pltData <- pltData[order(pltData$values, decreasing = TRUE), , drop = FALSE]

pltMillion <- ggplot(
    pltData,
    aes(x = "", y = values, fill = row.names(pltData))
) +
    geom_bar(stat = "identity", width = 1, color = "white") +
    coord_polar(theta = "y") +
    geom_label_repel(aes(label = paste(format(round(values / 1e6, 1), trim = TRUE), "M")), position = position_stack(vjust = 0.5)) +
    theme_void() +
    guides(fill = guide_legend(title = element_blank())) +
    scale_fill_discrete(labels = pltData)
pltPercentage <- ggplot(
    pltData,
    aes(x = "", y = values, fill = row.names(pltData))
) +
    geom_bar(stat = "identity", width = 1, color = "white") +
    coord_polar(theta = "y") +
    geom_label_repel(aes(label = paste(format(round((values / sum(pltData$values)) * 100), trim = TRUE), "%")), position = position_stack(vjust = 0.5)) +
    theme_void() +
    guides(fill = guide_legend(title = element_blank()))

print(ggarrange(
    pltMillion,
    pltPercentage,
    labels = "Count fractions of all samples combined",
    common.legend = TRUE,
    legend = "bottom",
    legend.grob = get_legend(pltMillion),
    ncol = 2,
    nrow = 1
))
```
<pre>



</pre>
### Sparsity plot
A simple plot of the concentration of counts in a single sample 
over the sum of counts per gene. Not technically the same as "sparsity", 
but this plot is useful diagnostic for datasets which might not fit a 
negative binomial assumption: genes with many zeros and individual very 
large counts are difficult to model with the negative binomial 
distribution.
```{r plotSparsity}
plotSparsity(
    ddsDay3,
    col = ddsDay3$condition,
    ann = TRUE,
    cex = 0.4,
    pch = 4
)
legend(
    "topright",
    legend = levels(ddsDay3$condition),
    pch = 4,
    col = unique(ddsDay3$condition)
)
```
<pre>



</pre>
### Plot dispersion estimates
```{r plotDispEst}
DESeq2::plotDispEsts(ddsDay3)
```
<pre>



</pre>
### Bland-Altman plot 
An MA-plot is a plot of log-intensity ratios (M-values) versus intensity averages (A-values). 
```{r plotMA}
DESeq2::plotMA(resultsDay3,
    ylim = c(-5, 5),
    colNonSig = "black",
    colSig = "red"
)
legend("topright",
    legend = c("padj > 0.1", "padj < 0.1"),
    pch = 16,
    col = c("black", "red")
)
```
<pre>



</pre>
### Bland-Altman plot (LFCshrink)
LfcShrink adds shrunken log2-fold changes (LFC) and standard error to a results 
table from DESeq run without LFC shrinkage.
<br>
</br>
Specifying apeglm passes along DESeq2 MLE log2 fold 
changes and standard errors to the apeglm function in the apeglm 
package, and re-estimates posterior LFCs for the coefficient 
specified by coef.
```{r plotMAlfc}
DESeq2::plotMA(ddsDay3Shrink,
    ylim = c(-5, 5),
    colNonSig = "black",
    colSig = "red"
)
legend(
    "topright",
    legend = c("padj > 0.1", "padj < 0.1"),
    pch = 16,
    col = c("black", "red")
)
```
<pre>



</pre>
### Mean vs sd (normTransform) 
```{r meanSdPlotNorm}
meanSdPlot(assay(ddsDay3Norm))
```
<pre>



</pre>
### Mean vs sd (vst)
```{r meanSdPlotVst}
meanSdPlot(assay(ddsDay3Vst))
```
<pre>



</pre>
### Mean vs sd (rlog)
```{r meanSdPlotRlog}
meanSdPlot(assay(ddsDay3Rlog))
```
<pre>



</pre>
### P-values histogram
The distribution of p-values across the ~20k hypothesis tested. 
```{r pValues}
ggplot(
    data = na.omit(as.data.frame(resultsDay3)),
    aes(x = pvalue)
) +
    geom_histogram(bins = 150)
```
<pre>



</pre>
### Adjusted p-value histogram
The distribution of p-adjusted (Benjamini-Hochberg) values across the ~20k hypothesis tested. 
```{r padjValues}
ggplot(
    data = na.omit(as.data.frame(resultsDay3)),
    aes(x = padj)
) +
    geom_histogram(bins = 150)
```
<pre>



</pre>
### Ratio top5/sample
Piechart showing the number of unmapped reads, various mapped reads and the fraction of the 5 most highly expressed genes for each sample. 
```{r MappingInfoSample}
for (i in colnames(ddsDay3Counts)) {
    total_reads <- (as.numeric(gsub(",", "", stats_hisat2[paste("hisat2/", i, sep = ""), "reads"])))
    total_mapped <- ddsDay3SampleCounts[i, ]
    top_twenty <- as.data.frame(ddsDay3Counts[order(ddsDay3Counts[, i], decreasing = TRUE), i][1:5], header = TRUE)
    top_twenty_sum <- colSums(top_twenty)
    unmapped_reads <- total_reads - total_mapped
    remaining_mapped <- total_mapped - colSums(top_twenty)

    pltData <- data.frame(
        row.names = c("unmapped reads", "various", row.names(top_twenty)),
        values = mapply(c, unmapped_reads, remaining_mapped, top_twenty)
    )

    pltMillion <- ggplot(
        pltData,
        aes(x = "", y = values, fill = row.names(pltData))
    ) +
        geom_bar(stat = "identity", width = 1, color = "white") +
        coord_polar(theta = "y") +
        geom_label_repel(aes(label = paste(format(round(values / 1e6, 1), trim = TRUE), "M")), position = position_stack(vjust = 0.5)) +
        theme_void() +
        guides(fill = guide_legend(title = element_blank()))
    pltPercentage <- ggplot(
        pltData,
        aes(x = "", y = values, fill = row.names(pltData))
    ) +
        geom_bar(stat = "identity", width = 1, color = "white") +
        coord_polar(theta = "y") +
        geom_label_repel(aes(label = paste(format(round((values / colSums(pltData)) * 100), trim = TRUE), "%")), position = position_stack(vjust = 0.5)) +
        theme_void() +
        guides(fill = guide_legend(title = element_blank()))

    print(ggarrange(
        pltMillion,
        pltPercentage,
        labels = paste("Sample: ", i, sep = ""),
        common.legend = TRUE,
        legend = "bottom",
        ncol = 2,
        nrow = 1
    ))
}
```
<pre>



</pre>
## Genes differential expression
### Principal component analysis (DESeq2)
Generic PCA plot of regularized log-transformed data. 
The rlog function transforms the count data to the 
log2 scale in a way which minimizes differences between 
samples for rows with small counts, and which normalizes with 
respect to library size.
```{r pcaDESeq2}
#DESeq2:::plotPCA.DESeqTransform
plotData <- DESeq2::plotPCA(ddsDay3Rlog, intgroup = "condition", returnData = TRUE)
ggplot(plotData, aes(x = PC1, y = PC2, color = condition)) +
geom_point(size = 4) +
scale_color_manual(values = c(sham = "black", "4Rx" = "#000099", ctrl = "#990000")) +
xlab(paste("PC1: ", round(attr(plotData, "percentVar")[1], digits = 2))) + 
ylab(paste("PC2: ", round(attr(plotData, "percentVar")[2], digits = 2)))
```
<pre>



</pre>
### Principal component analysis (R built-in)
```{r pcaR}
ddsDay3_rlog_PCA <- prcomp(t(assay(ddsDay3Rlog)), scale = TRUE)
var_explained <- data.frame("var_explained" = ddsDay3_rlog_PCA$sdev**2/sum(ddsDay3_rlog_PCA$sdev**2))
var_explained$PC <- factor(sprintf("PC%s", seq(1:15)), levels = sprintf("PC%s", seq(1:15)))
# variation explained by the respectice PC
p1 <- ggplot(var_explained, aes(y = var_explained, x = PC)) + 
geom_bar(stat = "identity") +
geom_text(aes(label = round(var_explained, digits = 2)), vjust = -0.5) + 
ggtitle("Variance explained by the respective PC's")
# PCA
p2 <- ddsDay3_rlog_PCA$x %>%
    as.data.frame %>%
        ggplot(aes(x = PC1, y = PC2, color = samplesDay3$condition)) + 
        geom_point(size = 4) + guides(color = guide_legend("condition")) +
        scale_color_manual(values = c("ctrl" = "#990000", "4Rx" = "#000099", "sham" = "grey35")) + 
        labs (
            x = paste ("PC1: ", round(var_explained[1,1]*100, 0), "%"), 
            y = paste("PC2: ", round(var_explained[2,1]*100, 0), "%")) +
        ggtitle("PCA")
# PCA with k-means clustering
set.seed(123)
ddsDay3_rlog_PCA_kmeans <- kmeans(as.data.frame(ddsDay3_rlog_PCA$x[,1:2]), centers = 4, iter.max = 10, nstart = 25)
p3 <- ddsDay3_rlog_PCA$x %>%
    as.data.frame %>%
        ggplot(aes(x = PC1, y = PC2, color = samplesDay3$condition, shape = factor(ddsDay3_rlog_PCA_kmeans$cluster))) + 
        geom_point(size = 4) + 
        guides(color = guide_legend("condtion"), shape = guide_legend("k-means cluster")) +
        scale_color_manual(values = c("ctrl" = "#990000", "4Rx" = "#000099", "sham" = "grey35")) +
        scale_shape_manual(values = c(15, 16, 17, 18)) +
        ggtitle("PCA with kmeans clustering") + 
        labs (x = paste ("PC1: ", round(var_explained[1,1]*100, 0), "%"), 
        y = paste("PC2: ", round(var_explained[2,1]*100, 0), "%"))
p1 + p2 + p3 + plot_layout(2,2)
```
<pre>



</pre>
### Heatmap of sample distance
Euclidean distances of the transformed, normalized samples, plotted in a heatmap. 
```{r heatmapSamples}
ensembl_raw_salmon_dist <- dist(t(assay(ddsDay3Vst)), method = "euclidean")
ensembl_raw_salmon_distMatrix <- as.matrix(ensembl_raw_salmon_dist)
rownames(ensembl_raw_salmon_distMatrix) <- paste(colnames(ddsDay3Vst), ddsDay3Vst$condition, sep = "-")
colnames(ensembl_raw_salmon_distMatrix) <- paste(colnames(ddsDay3Vst), ddsDay3Vst$condition, sep = "-")
paletteLength <- 255
myColor <- colorRampPalette(c("#000099", "white"))(paletteLength)
plt <- pheatmap(ensembl_raw_salmon_distMatrix,
    clustering_distance_rows = ensembl_raw_salmon_dist,
    clustering_distance_cols = ensembl_raw_salmon_dist,
    col = myColor, 
)
plt
```
<pre>



</pre>
### Volcano plot (trt vs ctrl)
Scatterplot showing statistical significance [-log10(padj)] versus magnitude of change [log2FoldChange].
```{r volcanoPlot}
resultsDay3_volcano <- resultsDay3
resultsDay3_volcano$diffExpressed <- "NO"
resultsDay3_volcano$diffExpressed[resultsDay3_volcano$padj < 0.1 & resultsDay3_volcano$log2FoldChange < 0] <- "Down"
resultsDay3_volcano$diffExpressed[resultsDay3_volcano$padj < 0.1 & resultsDay3_volcano$log2FoldChange > 0] <- "Up"

ggplot(
    data = as.data.frame(resultsDay3),
    aes(
        x = log2FoldChange,
        y = -log10(padj),
        col = resultsDay3_volcano$diffExpressed,
        label = rownames(resultsDay3)
    )
) +
    geom_point(size = 2, na.rm = TRUE) +
    theme_minimal() +
    theme(legend.title = element_blank()) +
    geom_vline(xintercept = c(1, -1), col = "gray", linetype = "dashed") +
    geom_hline(yintercept = -log10(.1), col = "gray", linetype = "dashed") +
    scale_color_manual(
        values = c("#000099", "grey80", "#990000"),
        labels = c("sig DOWN", "no sig", "sig UP")
    ) +
    geom_text_repel(
        aes(
            x = log2FoldChange,
            y = -log10(padj),
            label = ifelse(padj < 0.1, as.character(rownames(resultsDay3)), "")
        ),
        hjust = 0,
        vjust = -1.2,
        segment.color = NA
    )
```
<pre>



</pre>
### Volcano Plot (sham vs ctrl)
```{r volcanoPlotShamVsCtrl}
resultsDay3Sham_volcano <- resultsDay3Sham
resultsDay3Sham_volcano$diffExpressed <- "NO"
resultsDay3Sham_volcano$diffExpressed[resultsDay3Sham_volcano$padj < 0.1 & resultsDay3Sham_volcano$log2FoldChange < 0] <- "Down"
resultsDay3Sham_volcano$diffExpressed[resultsDay3Sham_volcano$padj < 0.1 & resultsDay3Sham_volcano$log2FoldChange > 0] <- "Up"

ggplot(
    data = as.data.frame(resultsDay3Sham),
    aes(
        x = log2FoldChange,
        y = -log10(padj),
        col = resultsDay3Sham_volcano$diffExpressed,
        label = rownames(resultsDay3Sham)
    )
) +
    geom_point(size = 2, na.rm = TRUE) +
    theme_minimal() +
    theme(legend.title = element_blank()) +
    geom_vline(xintercept = c(1, -1), col = "gray", linetype = "dashed") +
    geom_hline(yintercept = -log10(.1), col = "#646363", linetype = "dashed") +
    scale_color_manual(
        values = c("#000099", "grey", "#990000"),
        labels = c("sig Down", "no sig", "sig Up")
    ) + 
    xlim(c(-20, 20))
```
<pre>



</pre>
### Heatmap padj<0.1 clustered
The normalized expression of our candidate genes across all samples plotted in a heatmap.
```{r heatmapClustered}
ddsDay3_vst_cand <- assay(ddsDay3Vst)[featureNamesDay3, ]
ddsDay3_vst_cand <- ddsDay3_vst_cand - rowMeans(ddsDay3_vst_cand)
paletteLength <- 50
myColor <- colorRampPalette(c("#990000", "white", "#000099"))(paletteLength)
myBreaks <- c(
    seq(min(ddsDay3_vst_cand), 0, length.out = ceiling(paletteLength / 2) + 1),
    seq(max(ddsDay3_vst_cand) / paletteLength, max(ddsDay3_vst_cand), length.out = floor(paletteLength / 2)))
pltNoSham <- function(){
    pltNoSham <- pheatmap(
    ddsDay3_vst_cand[, !grepl("sham", samplesDay3$condition)],
    color = myColor,
    breaks = myBreaks,
    annotation_col = samplesDay3[, "condition", drop = FALSE],
    annotation_colors = list(condition = c(ctrl = "grey60", "4Rx" = "black")),
    show_colnames = FALSE,
    scale = "row", 
    silent = TRUE)
    rowOrder <<- pltNoSham$tree_row$order # rather than returning we <<- add the variable to the workspace
    return(pltNoSham)}
pltSham <- function(){
    pltSham <- pheatmap(
    ddsDay3_vst_cand[, grepl("sham", samplesDay3$condition)][rowOrder, ],
    color = myColor,
    breaks = myBreaks,
    annotation_col = samplesDay3[, "condition", drop = FALSE],
    annotation_colors = list(condition = c(sham = "white")),
    show_colnames = FALSE,
    cluster_rows = FALSE, 
    silent = TRUE)
    return(pltSham) }
ggarrange(
    as.ggplot(pltNoSham()),
    as.ggplot(pltSham()),
    common.legend = TRUE,
    legend = "bottom",
    ncol = 2,
    nrow = 1,
    widths = c(2, 1))
```
<pre>



</pre>
### Heatmap NOT Clustered (ordered by LFC and condition)
```{r heatmapUnclustered}
samplesDay3$condition

ddsDay3_vst_cand_log2FCord <- assay(ddsDay3Vst)[row.names(featuresDay3[order(featuresDay3$log2FoldChange, decreasing = TRUE), ]), ]
ddsDay3_vst_cand_log2FCord <- as.data.frame(ddsDay3_vst_cand_log2FCord - rowMeans(ddsDay3_vst_cand_log2FCord))

paletteLength <- 50
myColor <- colorRampPalette(c("#000099", "white", "#990000"))(paletteLength)
myBreaks <- c(
    seq(min(ddsDay3_vst_cand), 0, length.out = ceiling(paletteLength / 2) + 1),
    seq(max(ddsDay3_vst_cand) / paletteLength, max(ddsDay3_vst_cand), length.out = floor(paletteLength / 2)))
plt <- pheatmap(
    ddsDay3_vst_cand_log2FCord,
    color = myColor,
    breaks = myBreaks,
    annotation_col = samplesDay3[,"condition",drop = FALSE],
    annotation_colors = list(condition = c(ctrl = "grey60", "4Rx" = "black", sham = "white")),
    show_colnames = FALSE,
    cluster_rows = FALSE,
    cluster_cols = FALSE,
    scale = "row"
)
plt
```
<pre>



</pre>
### Barplot up/down
This plot summarizes the number of significantly up and down-regulated genes based on different padj and log2FoldChange thresholds (comparison control vs treatment, control is always the base level of the comparison).
```{r barplotUpDown}
filterUp <- function(df, log2fc = 1, p = 0.1) {
    nrow(df[df$log2FoldChange >= log2fc & !is.na(df$padj) & df$padj <= p, ])}
filterDown <- function(df, log2fc = 1, p = 0.1) {
    nrow(df[df$log2FoldChange <= -log2fc & !is.na(df$padj) & df$padj <= p, ])}
pVals <- c(0.001, 0.01, 0.05, 0.1)
fcVals <- c(0:(max(featuresDay3$log2FoldChange) + 1))
summaryUpDown <- do.call(rbind, lapply(pVals, function(p) {
    do.call(rbind, lapply(fcVals, function(f) {
        up <- filterUp(resultsDay3, f, p)
        down <- filterDown(resultsDay3, f, p)
        return(data.frame(
            "log2FoldChange" = f, "padj" = p,
            "upRegulated" = up, "downRegulated" = down
        ))
    }))
}))
dataUpDown <- melt(summaryUpDown, id.vars = c("log2FoldChange", "padj"))

ggplot(
    dataUpDown,
    aes(x = log2FoldChange, y = value)) +
geom_bar(
    aes(fill = variable),
    stat = "identity",
    position = "dodge") +
facet_grid(~padj) +
scale_fill_manual(values = c("upRegulated" = "#990000", "downRegulated" = "#000099")) +
theme(legend.position = "bottom", legend.title = element_blank()) +
labs(
    title = "Number of differentially up/down regulated genes",
    subtitle = "based on different padj values and log2FoldChange cut-off values") +
ylab("gene count")
```
<pre>



</pre>
### Count plots top-features 
```{r countPlots}
# creating a special dataframe with additional metadata
plt_featuresDds <- ddsDay3[featureNamesDay3, ]
plt_featuresCounts <- as.data.frame(t(counts(plt_featuresDds)))
plt_featuresCounts <- merge(
    plt_featuresCounts,
    samplesDay3,
    by.x = "row.names",
    by.y = "fileName",
    all.x = TRUE,
    all.y = TRUE)
rownames(plt_featuresCounts) <- plt_featuresCounts$Row.names
plt_featuresCounts$Row.names <- NULL
plt_featuresCounts$sample <- rownames(plt_featuresCounts)
plt_featuresCounts <- melt(plt_featuresCounts, id.vars = c("sample", "condition", "brainRegion", "timepoint"))
plt_featuresPadj <- data.frame(padj = featuresDay3$padj, row.names = rownames(featuresDay3))
plt_featuresDiverse <- merge(
    plt_featuresCounts,
    plt_featuresPadj,
    by.x = "variable",
    by.y = "row.names",
    all.x = TRUE,
    all.y = TRUE)
## the actual plotting
set.seed(35)
ggplot(
    plt_featuresDiverse,
    aes(x = variable, y = log10(value), color = condition, size = -log10(padj))) +
geom_point() +
geom_jitter(height = NULL, width = 0.35) +
scale_color_manual(values = c("#990000", "grey35", "#000099")) +
ylab("log10(counts)") +
xlab("gene") +
scale_size_continuous(limits = NULL, breaks = c(4, 8, 12), range = c(2, 6)) +
guides(size = guide_legend(override.aes = list(color = "grey")), 
    color = guide_legend(override.aes = list(size = 3)))
```
<pre>



</pre>
### Biological processes (GO) of our top-features level 2
```{r, GoBp2}
GoBp2_plot <- featuresGobp2@result[which(featuresGobp2@result$Count > 0), ]

for (i in rownames(featuresDay3Metadata)) {
    GoBp2_plot[, i] <- 0
    GoBp2_plot[grep(i, GoBp2_plot$geneID), i] <- 1
    GoBp2_plot[, i] <- factor(GoBp2_plot[, i], levels = c("0", "1"))
}

GoBp2_plotMelt <- GoBp2_plot[, rownames(featuresDay3Metadata)]
GoBp2_plotMelt$Description <- GoBp2_plot$Description
GoBp2_plotMelt <- melt(GoBp2_plotMelt, id.vars = "Description")

GoBp2_plotMelt$value <- factor(GoBp2_plotMelt$value, levels = c("0", "1"))

ggplot(
    data = GoBp2_plotMelt,
    aes(x = variable, y = Description)) +
geom_point(size = 10, colour = "black", alpha = I(ifelse(GoBp2_plotMelt$value == 0, 0, 1))) +
scale_x_discrete(guide = guide_axis(angle = 90))
```
<pre>


</pre> 
### Biological processes (GO) of our top-features level 3
```{r GoBp3}
GoBp3_plot <- featuresGobp3@result[which(featuresGobp3@result$Count > 0), ]

for (i in rownames(featuresDay3Metadata)) {
    GoBp3_plot[, i] <- 0
    GoBp3_plot[grep(i, GoBp3_plot$geneID), i] <- 1
    GoBp3_plot[, i] <- factor(GoBp3_plot[, i], levels = c("0", "1"))
}

GoBp3_plotMelt <- GoBp3_plot[, rownames(featuresDay3Metadata)]
GoBp3_plotMelt$Description <- GoBp3_plot$Description
GoBp3_plotMelt <- melt(GoBp3_plotMelt, id.vars = "Description")

GoBp3_plotMelt$value <- factor(GoBp3_plotMelt$value, levels = c("0", "1"))

ggplot(
    data = GoBp3_plotMelt,
    aes(x = variable, y = Description)) +
geom_point(size = 3, colour = "black", alpha = I(ifelse(GoBp3_plotMelt$value == 0, 0, 1))) +
scale_x_discrete(guide = guide_axis(angle = 90)) +
theme_minimal() +
theme(axis.text.y=element_text(size=5, face = "bold"))
```
<pre>



</pre>
## Transcripts technical plots
### DESeq2 model transcripts 
```{r RcodeTx, message = FALSE}
# import of data, same as for genes
tx_txi <- tximport(quantFiles, type = "salmon", txIn = TRUE, txOut = TRUE)
# subsetting the txi object for different conditions
tx_txiDay3 <- lapply(tx_txi, function(x) if(is.matrix(x)) return(x[,samples$fileName[which(samples$timepoint == "day3")]]) else return(x))
tx_txiDay7Penumbra <- lapply(tx_txi, function(x) if(is.matrix(x)) return(x[,samples$fileName[which(c(samples$timepoint == "day7" & samples$brainRegion == "ipsiPenumbra"))]]) else return(x))
tx_txiDay7Core <- lapply(tx_txi, function(x) if(is.matrix(x)) return(x[,samples$fileName[which(c(samples$timepoint == "day7" & samples$brainRegion == "ipsiCore"))]]) else return(x))
# deseq2 model 
tx_ddsDay3 <- DESeqDataSetFromTximport(tx_txiDay3, colData = samples[which(samples$timepoint == "day3"),], design = ~condition)
tx_ddsDay3$condition <- relevel(tx_ddsDay3$condition, ref = "ctrl")
tx_ddsDay3_keep <- rowSums(counts(tx_ddsDay3) >= 5) >= 3
tx_ddsDay3 <- tx_ddsDay3[tx_ddsDay3_keep,]
tx_ddsDay3 <- DESeq(tx_ddsDay3)
# results 
tx_resultsDay3 <- results(tx_ddsDay3, alpha = 0.1, contrast = c("condition", "4Rx", "ctrl"))
tx_resultsDay3Sham <- results(tx_ddsDay3, alpha = 0.1, contrast = c("condition", "sham", "ctrl"))
tx_resultsDay3_NA <- tx_resultsDay3[!complete.cases(resultsDay3),]
tx_resultsDay3_NA_counts <- assay(tx_ddsDay3)[rownames(tx_ddsDay3) %in% rownames(tx_resultsDay3_NA),]
# selection specifics sets of results
tx_featureNamesDay3 <- row.names(subset(tx_resultsDay3, padj < 0.1))
tx_featuresDay3 <- subset(tx_resultsDay3, padj < 0.1)
topLfcDay3 <- rbind(
    head(tx_featuresDay3[order(tx_featuresDay3$log2FoldChange, decreasing = TRUE),], n = 10), 
    tail(tx_featuresDay3[order(tx_featuresDay3$log2FoldChange, decreasing = TRUE),], n = 10))
topPadjDay3 <- head(tx_featuresDay3[order(tx_featuresDay3$padj, decreasing = FALSE),], n = 20)
tx_resultsDay3_NA <- tx_resultsDay3[!complete.cases(tx_resultsDay3),]
# counts per sample, counts per transcript
tx_ddsDay3Counts <- assay(tx_ddsDay3)
tx_ddsDay3SampleCounts <- as.data.frame(colSums(tx_ddsDay3Counts))
tx_ddsDay3GeneCounts <- as.data.frame(rowSums(tx_ddsDay3Counts))
names(tx_ddsDay3GeneCounts) <- "counts"
tx_ddsDay3GeneCounts <- tx_ddsDay3GeneCounts[order(tx_ddsDay3GeneCounts$counts, decreasing = TRUE), , drop = FALSE]
head(tx_ddsDay3GeneCounts)

# transcript specific set of results (gene annotation)
tx_resultsDay3Metadata <- merge(
    as.data.frame(
        tx_resultsDay3),
        tx2gene, 
        by.x= "row.names", 
        by.y = "X1",
        all.x = TRUE, 
        all.y = FALSE)
names(tx_resultsDay3Metadata)[names(tx_resultsDay3Metadata) == "X2"] <- "gene"
tx_resultsDay3Metadata <- tx_resultsDay3Metadata %>% relocate("gene", .after = "Row.names")
tx_featuresDay3Metadata <- subset(tx_resultsDay3Metadata, padj < 0.1)
# normalizations and transformations 
tx_ddsDay3_vst <- vst(tx_ddsDay3, blind = FALSE)
tx_ddsDay3_rlog <- rlog(tx_ddsDay3, blind = TRUE)
tx_ddsDay3_normTransform <- normTransform(tx_ddsDay3) ## NEW ------
tx_ddsDay3_lfcShrink <- lfcShrink(tx_ddsDay3, coef = "condition_4Rx_vs_ctrl", type = "apeglm")
```
<pre>



</pre>
### Reads assigned to transcripts
```{r TxReadsAssigned}
tx_pltCounts <- as.data.frame(colSums(tx_txiDay3$counts))
tx_pltCounts$condition <- samplesDay3$condition
names(tx_pltCounts)[names(tx_pltCounts) == "colSums(tx_txiDay3$counts)"] <- "counts"
tx_pltCounts_quantiles <- quantile(tx_pltCounts$counts, probs = c(0.05, 0.25, 0.75, 0.95))

ggplot(
    tx_pltCounts, 
    aes(x = rownames(tx_pltCounts), y = counts), 
    col = condition
) + 
geom_bar(
    aes(fill = condition), 
    stat = "identity"
) + 
geom_hline(
    yintercept = as.numeric(tx_pltCounts_quantiles), 
    color = "red"
) + 
geom_label_repel(
    data = data.frame(x = 0, y = as.numeric(tx_pltCounts_quantiles)), 
    aes(x = x, y = y, label = names(tx_pltCounts_quantiles))
) +
scale_y_continuous( labels = scales::comma) + 
coord_flip () + 
xlab("sample")
```
<pre>



</pre>
### Sparsity plot
A simple plot of the concentration of counts in a single sample 
over the sum of counts per gene. Not technically the same as "sparsity", 
but this plot is useful diagnostic for datasets which might not fit a 
negative binomial assumption: genes with many zeros and individual very 
large counts are difficult to model with the negative binomial 
distribution.
```{r TxPlotSparsity}
plotSparsity(
    tx_ddsDay3, 
    col=tx_ddsDay3$condition, 
    ann = TRUE, 
    cex = 0.4, 
    pch = 4) 
legend(
    "topright", 
    legend=levels(tx_ddsDay3$condition), 
    pch = 4, 
    col = unique(tx_ddsDay3$condition))
```
<pre>



</pre>
### Plot dispersion estimates
```{r plotDispEst}
DESeq2::plotDispEsts(tx_ddsDay3)
```
<pre>



</pre>
### Bland-Altman plot
An MA-plot is a plot of log-intensity ratios (M-values) versus intensity averages (A-values). 
```{r TxPlotMA}
DESeq2::plotMA(tx_resultsDay3, 
    colNonSig = "black", 
    colSig = "red")
legend("topright", 
legend = c("padj > 0.1", "padj < 0.1"), 
pch = 16, 
col = c("black", "red"))
```
<pre>



</pre>
### Bland-Altman plot (LFCshrink) 
LfcShrink adds shrunken log2-fold changes (LFC) and SE to a results 
table from DESeq run without LFC shrinkage.
<br>
</br>
Specifying apeglm passes along DESeq2 MLE log2 fold 
changes and standard errors to the apeglm function in the apeglm 
package, and re-estimates posterior LFCs for the coefficient 
specified by coef.
```{r TxPlotMAlfc}
DESeq2::plotMA(tx_ddsDay3_lfcShrink, 
    ylim = c(-5, 5),
    colNonSig = "black", 
    colSig = "red")
legend(
    "topright", 
    legend = c("padj > 0.1", "padj < 0.1"), 
    pch = 16, 
    col = c("black", "red"))
```
<pre>



</pre>
## Transcripts differential expression
### PCA
Generic PCA plot of regularized log-transformed data. 
The rlog function transforms the count data to the 
log2 scale in a way which minimizes differences between 
samples for rows with small counts, and which normalizes with 
respect to library size.
```{r TxPca}
#DESeq2:::plotPCA.DESeqTransform
plotData <- DESeq2::plotPCA(tx_ddsDay3_rlog, intgroup = "condition", returnData = TRUE)
ggplot(plotData, aes(x = PC1, y = PC2, color = condition)) +
geom_point(size = 4) +
scale_color_manual(values = c(sham = "black", "4Rx" = "#000099", ctrl = "#990000")) +
xlab(paste("PC1: ", round(attr(plotData, "percentVar")[1], digits = 2))) + 
ylab(paste("PC2: ", round(attr(plotData, "percentVar")[2], digits = 2)))
```
<pre>



</pre>
### Heatmap of sample distance
Euclidean distances of the transformed, normalized samples, plotted in a heatmap. 
```{r TxHeatmapSamples}
tx_ensembl_raw_salmon_dist <- dist(t(assay(tx_ddsDay3_vst)), method = "euclidean")
tx_ensembl_raw_salmon_distMatrix <- as.matrix(tx_ensembl_raw_salmon_dist)
rownames(tx_ensembl_raw_salmon_distMatrix) <- paste(colnames(tx_ddsDay3_vst), tx_ddsDay3_vst$condition, sep = "-")
colnames(tx_ensembl_raw_salmon_distMatrix) <- paste(colnames(tx_ddsDay3_vst), tx_ddsDay3_vst$condition, sep = "-")

colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
plt <- pheatmap(tx_ensembl_raw_salmon_distMatrix,
         clustering_distance_rows=tx_ensembl_raw_salmon_dist,
         clustering_distance_cols=tx_ensembl_raw_salmon_dist,
         col=colors)
plt 
```
<pre>



</pre>
### Volcano plot (trt vs ctrl)
Scatterplot showing statistical significance [-log10(padj)] versus magnitude of change [log2FoldChange].
```{r TxvolcanoPlot}
tx_resultsDay3_volcano <- tx_resultsDay3
tx_resultsDay3_volcano$diffExpressed <- "NO"
tx_resultsDay3_volcano$diffExpressed[tx_resultsDay3_volcano$padj < 0.1 & tx_resultsDay3_volcano$log2FoldChange < 0] <- "Down"
tx_resultsDay3_volcano$diffExpressed[tx_resultsDay3_volcano$padj < 0.1 & tx_resultsDay3_volcano$log2FoldChange > 0] <- "Up"

ggplot (
    data = as.data.frame(tx_resultsDay3), 
    aes(x = log2FoldChange, 
    y=-log10(padj), 
    col = tx_resultsDay3_volcano$diffExpressed, 
    label = rownames(tx_resultsDay3))) +
xlim(-7, 7) +
ylim(0, 7) +
geom_point(size = 2, na.rm = TRUE) + 
theme_minimal() +
theme(legend.title=element_blank()) +
geom_vline(xintercept = c(1, -1), col = "gray", linetype = "dashed") +
geom_hline(yintercept = -log10(.1), col = "#646363", linetype = "dashed") + 
scale_color_manual(
    values = c("#00AFBB", "grey", "#C4961A"),
    labels = c("sig Down", "no sig", "sig UP"))  
```
<pre>



</pre>
### Volcano Plot (sham vs ctrl)
```{r TxVolcanoPlotShamVsCtrl}
tx_resultsDay3Sham_volcano <- tx_resultsDay3Sham
tx_resultsDay3Sham_volcano$diffExpressed <- "NO"
tx_resultsDay3Sham_volcano$diffExpressed[tx_resultsDay3Sham_volcano$padj < 0.1 & tx_resultsDay3Sham_volcano$log2FoldChange < 0] <- "Down"
tx_resultsDay3Sham_volcano$diffExpressed[tx_resultsDay3Sham_volcano$padj < 0.1 & tx_resultsDay3Sham_volcano$log2FoldChange > 0] <- "Up"

ggplot (
    data = as.data.frame(tx_resultsDay3Sham), 
    aes(x = log2FoldChange, 
    y=-log10(padj), 
    col = tx_resultsDay3Sham_volcano$diffExpressed, 
    label = rownames(tx_resultsDay3Sham))) +
geom_point(size = 2, na.rm = TRUE) + 
theme_minimal() +
theme(legend.title=element_blank()) +
geom_vline(xintercept = c(1, -1), col = "gray", linetype = "dashed") +
geom_hline(yintercept = -log10(.1), col = "#646363", linetype = "dashed") + 
scale_color_manual(
    values = c("#00AFBB", "grey", "#C4961A"),
    labels = c("sig Down", "no sig", "sig Up"))
```
<pre>



</pre>
### Heatmap significant transcripts
The normalized expression of our candidate transcripts across all samples plotted in a heatmap.
```{r TxHeatmapSignificantFeatures}
tx_ddsDay3_vst_cand <- assay(tx_ddsDay3_vst)[tx_featureNamesDay3,]
tx_ddsDay3_vst_cand <- tx_ddsDay3_vst_cand - rowMeans(tx_ddsDay3_vst_cand)

pheatmap(
    tx_ddsDay3_vst_cand, 
    annotation_col = samplesDay3[,"condition", drop = FALSE], 
    show_colnames = FALSE, 
    show_rownames = FALSE
)
plt <- recordPlot()
replayPlot(plt)
```
<pre>



</pre>
<pre>



</pre>
### Barplot up/down
This plot summarizes the number of significantly up and down-regulated transcripts based on different padj and log2FoldChange thresholds (comparison control vs treatment, control is always the base level of the comparison).
```{r TxBarplotUpDown}
filterUp <- function(df, log2fc = 1,  p = 0.1) {nrow(df[df$log2FoldChange >= log2fc & !is.na(df$padj) & df$padj <= p,])}
filterDown <- function(df, log2fc = 1,  p = 0.1) {nrow(df[df$log2FoldChange <= -log2fc & !is.na(df$padj) & df$padj <= p,])}
pVals <- c(0.001, 0.01, 0.05, 0.1)
fcVals <- c(0:(max(tx_featuresDay3$log2FoldChange) + 1))
summaryUpDown <- do.call(rbind, lapply(pVals, function(p){
    do.call(rbind, lapply(fcVals, function(f){
        up <- filterUp(tx_resultsDay3, f, p)
        down <- filterDown(tx_resultsDay3, f, p)
        return(data.frame("log2FoldChange" = f, "padj" = p, 
        "upRegulated" = up, "downRegulated" = down))
    }))
}))
dataUpDown <- melt(summaryUpDown, id.vars = c("log2FoldChange", "padj"))

ggplot(
    dataUpDown, 
    aes(x = log2FoldChange, y = value)) + 
geom_bar(
    aes(fill = variable),
    stat = "identity", 
    position = "dodge") +
facet_grid(~ padj) + 
theme(legend.position = "bottom", legend.title = element_blank()) + 
labs (
    title = "Number of differentially up/down regulated transcripts", 
    subtitle = "based on different padj values and log2FoldChange cut-off values") +
ylab("gene count")
```
<pre>



</pre>
### How many differentially expressed transcripts map to a single gene?
```{r TxSupportGene}
pltdata <- as.data.frame(table(table(tx_featuresDay3Metadata$gene)))

ggplot(
    data = pltdata, 
    aes(x = Var1, y = Freq)) +
geom_bar(stat = "identity", color = "blue", fill = "#00d5ff") + 
geom_text(aes(label = Freq), vjust = -0.3, size = 5) +
xlab("# of significant transcript assigned to gene") + 
ylab("# of genes") +
theme(axis.title = element_text(size = 5)) +
theme_minimal()
```
<pre> 



</pre>
## Pathway Enrichment 
### Code for Pathway enrichment
```{r RcodePathwayEnrichment, message = FALSE, warning = FALSE}
# GO Enrichment analysis
ensembl_raw_salmon_DESeq_GoBp <- enrichGO(rownames(featuresDay3), keyType = "SYMBOL", OrgDb = "org.Mm.eg.db", ont = "BP", pvalueCutoff = 0.1, pAdjustMethod = "BH", universe = rownames(resultsDay3))
ensembl_raw_salmon_DESeq_GoMf <- enrichGO(rownames(featuresDay3), keyType = "SYMBOL", OrgDb = "org.Mm.eg.db", ont = "MF", pvalueCutoff = 0.1, pAdjustMethod = "BH", universe = rownames(resultsDay3))
ensembl_raw_salmon_DESeq_GoCc <- enrichGO(rownames(featuresDay3), keyType = "SYMBOL", OrgDb = "org.Mm.eg.db", ont = "CC", pvalueCutoff = 0.1, pAdjustMethod = "BH", universe = rownames(resultsDay3))
# Molecular signature enrichment analysis
msigdbr_h_gene_sets <- msigdbr(species = "mouse", category = "H")
msigdbr_h <- clusterProfiler::enricher(
    gene = rownames(featuresDay3Metadata),
    universe = rownames(resultsDay3),
    pAdjustMethod = "BH",
    TERM2GENE = msigdbr_h_gene_sets[, c("gs_name", "gene_symbol")]
)
# Gene set enrichment analysis GO terms
ensembl_raw_salmon_DESeq_WaldStats <- resultsDay3$stat
names(ensembl_raw_salmon_DESeq_WaldStats) <- rownames(resultsDay3)
ensembl_raw_salmon_DESeq_WaldStats <- ensembl_raw_salmon_DESeq_WaldStats[order(ensembl_raw_salmon_DESeq_WaldStats, decreasing = TRUE)]
ensembl_raw_salmon_gsea <- gseGO(
    geneList = ensembl_raw_salmon_DESeq_WaldStats,
    ont = "BP",
    OrgDb = "org.Mm.eg.db",
    keyType = "SYMBOL",
    minGSSize = 60,
    eps = 0,
    seed = T
)
ensembl_raw_salmon_gsea <- ensembl_raw_salmon_gsea[order(ensembl_raw_salmon_gsea$NES), asis = TRUE]
ensembl_raw_salmon_gsea_simplify <- clusterProfiler::simplify(ensembl_raw_salmon_gsea)
### GSEA selection
ensembl_raw_salmon_gsea_selection <- ensembl_raw_salmon_gsea[c(
    which(ensembl_raw_salmon_gsea$ID == "GO:0001525"),
    which(ensembl_raw_salmon_gsea$ID == "GO:0050900"),
    which(ensembl_raw_salmon_gsea$ID == "GO:0045766"),
    which(ensembl_raw_salmon_gsea$ID == "GO:0001819"),
    which(ensembl_raw_salmon_gsea$ID == "GO:0002252"),
    which(ensembl_raw_salmon_gsea$ID == "GO:1903555"),
    which(ensembl_raw_salmon_gsea$ID == "GO:0071706"),
    which(ensembl_raw_salmon_gsea$ID == "GO:0042110"),
    which(ensembl_raw_salmon_gsea$ID == "GO:0032640"),
    which(ensembl_raw_salmon_gsea$ID == "GO:0032680"),
    which(ensembl_raw_salmon_gsea$ID == "GO:0002685"),
    which(ensembl_raw_salmon_gsea$ID == "GO:0007416")
), , asis = TRUE]
## GSEA results as dataframe
ensembl_raw_salmon_gseaDF <- as.data.frame(ensembl_raw_salmon_gsea)
ensembl_raw_salmon_gseaDF$leadTag <- as.integer(
    str_replace_all(
        str_replace_all(
            vapply(
                strsplit(ensembl_raw_salmon_gseaDF$leading_edge, ","), `[`, 1,
                FUN.VALUE = character(1)
            ), "tags=", ""
        ), "%", ""
    )
) / 100
ensembl_raw_salmon_gseaDF$leadGene <- as.integer(
    str_replace_all(
        str_replace_all(
            vapply(
                strsplit(ensembl_raw_salmon_gseaDF$leading_edge, ","), `[`, 2,
                FUN.VALUE = character(1)
            ), " list=", ""
        ), "%", ""
    )
) / 100
ensembl_raw_salmon_gseaDF$leadSignal <- as.integer(
    str_replace_all(
        str_replace_all(
            vapply(
                strsplit(ensembl_raw_salmon_gseaDF$leading_edge, ","), `[`, 3,
                FUN.VALUE = character(1)
            ), " signal=", ""
        ), "%", ""
    )
) / 100
ensembl_raw_salmon_gseaDF$leading_edge <- NULL
ensembl_raw_salmon_gseaDF <- ensembl_raw_salmon_gseaDF[order(ensembl_raw_salmon_gseaDF$leadTag, decreasing = TRUE), ]
ensembl_raw_salmon_gseaDF$Direction <- "DownRegulated"
ensembl_raw_salmon_gseaDF[which(ensembl_raw_salmon_gseaDF$enrichmentScore > 0), ]$Direction <- "UpRegulated"
# KEGG enrichment analysis STILL TO COME
# GSEA KEGG  STILL TO COME
# GSEA Molecular Signature STILL TO COME
```
<pre> 



</pre>
### Enrichment Scores 
**Definition of leading edge: The percentage of gene tags before (for positive ES) or after (for negative ES) the
peak in the running enrichment score S. The larger the percentage, the more tags in the
gene set contribute to the final enrichment score.**
<br></br>
**Defintion of tag: The percentage of genes in the gene list L before (for positive ES) or after (for
negative ES) the peak in the running enrichment score, thus it gives an indication of
where in the list the enrichment score is attained.**
<br></br>
**Definition of signal: The enrichment signal strength that combines the two previous
statistics: (Tag %) × (1 – Gene %) × (N / (N – Nh) , where n equals the number of genes
in the list and Nh is the number of genes in the gene set. The larger this quantity, the more
enriched the gene set is as a whole. If the gene set is entirely within the first Nh positions
in the list, then the signal strength is maximal or 1. If the gene set is spread throughout
the list, then the signal strength decreases toward 0.**
```{r gseaplotTop5NES}
## highest normalized enrichment score
ensembl_raw_salmon_gseaDF <- ensembl_raw_salmon_gseaDF[order(ensembl_raw_salmon_gseaDF$leadTag, decreasing = TRUE), ]
enrichplot::gseaplot2(ensembl_raw_salmon_gsea, geneSetID = rownames(head(ensembl_raw_salmon_gseaDF, n = 5)), title = "5 pathways with the highest absolute enrichment score", pvalue_table = TRUE )
## highest leading edge
ensembl_raw_salmon_gseaDF <- ensembl_raw_salmon_gseaDF[order(ensembl_raw_salmon_gseaDF$leadTag, decreasing = TRUE), ]
enrichplot::gseaplot2(ensembl_raw_salmon_gsea, geneSetID = rownames(head(ensembl_raw_salmon_gseaDF, n = 5)), title = "5 Pathways with the higest leading edge", pvalue_table = TRUE )
## highest tag 
ensembl_raw_salmon_gseaDF <- ensembl_raw_salmon_gseaDF[order(ensembl_raw_salmon_gseaDF$leadGene, decreasing = FALSE), ]
enrichplot::gseaplot2(ensembl_raw_salmon_gsea, geneSetID = rownames(head(ensembl_raw_salmon_gseaDF, n = 5)), title = "5 Pathways with the higest tag", pvalue_table = TRUE )
## highest signal
ensembl_raw_salmon_gseaDF <- ensembl_raw_salmon_gseaDF[order(ensembl_raw_salmon_gseaDF$leadSignal, decreasing = TRUE), ]
enrichplot::gseaplot2(ensembl_raw_salmon_gsea, geneSetID = rownames(head(ensembl_raw_salmon_gseaDF, n = 5)), title = "5 Pathways with the higest signal", pvalue_table = TRUE )
```
<pre>



</pre>
### Enrichment plot for a manual selection of Pathways
```{r gseaplotManualSelection}
enrichplot::gseaplot2(ensembl_raw_salmon_gsea, geneSetID = c("GO:0001525", "GO:0050900", "GO:0045766", "GO:0001819", "GO:0002252", "GO:1903555", "GO:0071706", "GO:0042110", "GO:0032640", "GO:0032680", "GO:0002685", "GO:0007416"))
```
<pre>



</pre>
### Dotplot of all Pathways, ordered and plotted by normalized enrichment score
```{r variousDotplots}
p1 <- enrichplot::dotplot(
    ensembl_raw_salmon_gsea, orderBy = "NES", x = "NES", showCategory = 800) + 
    theme(axis.text.y = element_blank()) +
    ggtitle("ordered NES of GO pathways")
p2 <- enrichplot::dotplot(
    ensembl_raw_salmon_gsea, x = "geneRatio", showCategory = 800) + 
    theme(axis.text.y = element_blank()) +
    ggtitle("ordered leading edge of Go pathways")
ensembl_raw_salmon_gseaDF <- ensembl_raw_salmon_gseaDF[order(ensembl_raw_salmon_gseaDF$NES, decreasing = TRUE), ]
ensembl_raw_salmon_gseaDF$ID <- factor(ensembl_raw_salmon_gseaDF$ID, levels = ensembl_raw_salmon_gseaDF$ID)
p3 <- ggplot(
    data = ensembl_raw_salmon_gseaDF,
    aes(y = ID, x = NES, color = Direction)) +
    geom_point(size = 2) +
    scale_color_manual(values = c("#000099", "#990000")) +
    theme(axis.text.y = element_blank()) +
    ggtitle("ordered NES of GO pathways")
ensembl_raw_salmon_gseaDF <- ensembl_raw_salmon_gseaDF[order(ensembl_raw_salmon_gseaDF$leadTag, decreasing = TRUE), ]
ensembl_raw_salmon_gseaDF$ID <- factor(ensembl_raw_salmon_gseaDF$ID, levels = ensembl_raw_salmon_gseaDF$ID)
p4 <- ggplot(
    data = ensembl_raw_salmon_gseaDF,
    aes(y = ID, x = leadTag, color = Direction)) +
    geom_point(size = 2) +
    scale_color_manual(values = c("#000099", "#990000")) +
    theme(axis.text.y = element_blank()) + 
    ggtitle("ordered leading tag of GO pathways")
p1 + p2 + p3 + p4 + plot_layout(2,2)
```
<pre>



</pre>
### The leadTags(support of the NES) for all GO terms plotted as barplot
```{r barplotLeadingEdge}
ggplot(
    data = data.frame(table(ensembl_raw_salmon_gseaDF$leadTag)),
    aes(y = Freq, x = Var1)) +
geom_bar(stat = "identity", color = "black", fill = "black") +
xlab("leadTag")
```
<pre>



</pre>
### The Normalized enrichment score for all GO terms as a histogram
```{r histogramNES}
ggplot(
    data = ensembl_raw_salmon_gseaDF,
    aes(x = NES, color = Direction, fill = Direction)
) +
    geom_histogram(binwidth = max(abs(ensembl_raw_salmon_gseaDF$NES)) / 80) +
    scale_color_manual(values = c("#000099", "#990000")) +
    scale_fill_manual(values = c("#000099", "#990000")) +
    xlab("Normalized enrichment score") +
    ylab("Count of GO Pathways") +
    xlim(-3, 3)
```
<pre>



</pre> 
### The 40 Gene Ontologies with the highest q-scores in a barplot 
```{r barplotTop40sig}
ensembl_raw_salmon_gseaDF_qValue40 <- ensembl_raw_salmon_gseaDF[order(ensembl_raw_salmon_gseaDF$qvalue), ]
ensembl_raw_salmon_gseaDF_qValue40 <- head(ensembl_raw_salmon_gseaDF_qValue40, n = 40)
ensembl_raw_salmon_gseaDF_qValue40 <- data.frame("Description" = ensembl_raw_salmon_gseaDF_qValue40$Description, "p.adjust" = ensembl_raw_salmon_gseaDF_qValue40$p.adjust, "qvalue" = ensembl_raw_salmon_gseaDF_qValue40$qvalue)
ensembl_raw_salmon_gseaDF_qValue40 <- melt(ensembl_raw_salmon_gseaDF_qValue40, id.vars = "Description")
ensembl_raw_salmon_gseaDF_qValue40 <- plyr::join(
    ensembl_raw_salmon_gseaDF_qValue40, 
    ensembl_raw_salmon_gseaDF[, c("Description", "Direction")], 
    by = "Description",
    type = "left", 
    match = "all")
# converting Description to factor with levels so ggplot doesn't reorder my plot
ensembl_raw_salmon_gseaDF_qValue40$Description <- factor(ensembl_raw_salmon_gseaDF_qValue40$Description, levels = unique(ensembl_raw_salmon_gseaDF_qValue40$Description), ordered = TRUE )
# actuall plotting
p1 <- ggplot(
    data = ensembl_raw_salmon_gseaDF_qValue40,
    aes(x = Description, y = -log10(value), pattern = variable, fill = Direction, color = Direction)) +
coord_flip() +
geom_bar_pattern(
    stat = "identity", 
    position = position_dodge(preserve = "single"), 
    color = "black", 
    pattern_fill = "black",
    pattern_angle = 45,
    pattern_density = 0.1,
    pattern_spacing = 0.025,
    pattern_key_scale_factor = 0.6) +
scale_pattern_manual(values = c(p.adjust = "stripe", qvalue = "none")) +
scale_color_manual(values = c("#000099", "#990000")) +
scale_fill_manual(values = c("#000099", "#990000")) +
labs(x = "-log 10", y = element_blank(), pattern = "padj/qvalue", color = "UpRegulated/DownRegulated") + 
guides(
    pattern = guide_legend(override.aes = list(fill = "white")),
    fill = guide_legend(override.aes = list(pattern = "none"))) +
scale_x_discrete(limits = rev(levels(ensembl_raw_salmon_gseaDF_qValue40$Description))) +
theme_minimal() + 
ggtitle ("padj and qvalue for the 40 most significant GO Pathways ordered by qvalue")
```
<pre>



</pre>
### The Normalized Enrichment Score of the top 20 up and top 20 downregulated pathways
```{r barplotTop40NES}
ensembl_raw_salmon_gseaDF <- ensembl_raw_salmon_gseaDF[order(ensembl_raw_salmon_gseaDF$NES), ]
ensembl_raw_salmon_gseaDF_top40 <- rbind(head(ensembl_raw_salmon_gseaDF, n = 20), tail(ensembl_raw_salmon_gseaDF, n = 20))
# converting Description to factor with levels so ggplot doesn't reorder my plot
ensembl_raw_salmon_gseaDF_top40$Description <- factor(ensembl_raw_salmon_gseaDF_top40$Description, levels = ensembl_raw_salmon_gseaDF_top40$Description)
# actuall plotting
ggplot(
    data = ensembl_raw_salmon_gseaDF_top40,
    aes(x = Description, y = NES, color = Direction, fill = Direction)) +
    coord_flip() +
    geom_bar(stat = "identity") +
    scale_color_manual(values = c("#000099", "#990000")) +
    scale_fill_manual(values = c("#000099", "#990000")) +
    theme_minimal()
```
<pre>



</pre>
### A small network plot of the genes mapping to a selection of GO terms
```{r networkGenesToGO, message = FALSE, warning = FALSE}
enrichplot::cnetplot(
    ensembl_raw_salmon_gsea_selection,
    showCategory = 12,
    color.params = list(foldChange = ensembl_raw_salmon_DESeq_WaldStats),
    node_label = "gene",
    color_category = "black"
) +
    guides(color = guide_legend(title = "Wald statistics"))
```
<pre> 



</pre>
### Heatmap plotting gene expression for a selection of GO terms
```{r heatmapGOselection, message = FALSE}
enrichplot::heatplot(
    ensembl_raw_salmon_gsea_selection,
    foldChange = ensembl_raw_salmon_DESeq_WaldStats,
    showCategory = 20) +
    theme(axis.text.x = element_blank()) +
    scale_fill_gradient2(
      high = "#990000", 
      low = "#000099",
      mid = "white",  
      name = "Wald statistics") +
    xlab("each bar is an individual gene")
```
<pre>



</pre> 
### Networking with vissE and igraph
<font size = "4">**In these plots each dot represents one significant gene ontology pathway.**</font>
```{r, GoNetwork, message = FALSE}
ensembl_raw_salmon_gsea_GSC <- list()
for (i in rownames(ensembl_raw_salmon_gsea@result)) {
    geneSet <- GeneSet(unlist(strsplit(ensembl_raw_salmon_gsea@result[i, "core_enrichment"], split = "/"))[], setName = i)
    ensembl_raw_salmon_gsea_GSC[[i]] <- geneSet
}
geneSetCollection <- GeneSetCollection(object = ensembl_raw_salmon_gsea_GSC)

## VISUALIZATION

# create an overlap network
gs_ovlap <- computeMsigOverlap(geneSetCollection, thresh = 0.25, measure = "jaccard")
gs_ovnet <- computeMsigNetwork(gs_ovlap, geneSetCollection)

# ADD GENE SET STATISTCS, just the padj of the GO pathways
geneSetsPadj <- ensembl_raw_salmon_gsea@result$p.adjust
names(geneSetsPadj) <- rownames(ensembl_raw_salmon_gsea@result)

# plot the network and overlay gene-set statistics
set.seed(36) # set seed for reproducible layout
plotMsigNetwork(ig = gs_ovnet, genesetStat = -log10(geneSetsPadj)) +
ggtitle("A network of all the significant GO pathways") + 
scale_fill_gradient(high = "#000099", low = "white", name = "-log10(p.adj)") + 
scale_radius(name= "# of genes in GO")

## IDENTIFY CLUSTERS

# identify clusters - order based on cluster size and avg gene-set stats
grps <- findMsigClusters(gs_ovnet,
    genesetStat = geneSetsPadj,
    alg = igraph::cluster_louvain,
    minSize = 5
)
# cluster_louvain works better than cluster_walktrap
# plot the top 12 clusters
set.seed(36) # set seed for reproducible layout
plotMsigNetwork(gs_ovnet, markGroups = grps, genesetStat = -log10(geneSetsPadj)) +
ggtitle("12 most significant GO pathway clusters, Louvain Algorithm") +
scale_fill_gradient(high = "#000099", low = "white", name = "-log10(p.adj)") + 
scale_radius(name= "# of genes in GO")
```
### Investigation of our Gene Ontology networks
```{r GoNetworkClusters, message = FALSE}
## OUR CLUSTERS IN DETAIL
set.seed(36) # set seed for reproducible layout
pltNetwk <- plotMsigNetwork(
    ig = gs_ovnet,
    markGroups = grps[1:6],
    genesetStat = -log10(geneSetsPadj),
    rmUnmarkedGroups = TRUE) +
ggtitle("6 most significant networks, Louvain Algorithm") +
scale_fill_gradient(high = "#000099", low = "white", name = "-log10(p.adj)") + 
scale_radius(name= "# of genes in GO")

##### creating wordclouds
descriptions <- ""
descriptionsList <- list()
for (cluster in grps){
    for (GO in cluster){
      descriptions <- paste(descriptions, ensembl_raw_salmon_gsea@result[GO, "Description"], sep = " ")
  }
  descriptionsList <- append(descriptionsList, descriptions)
  descriptions <- ""
}

#preparing data for plotting + additional parameters
termFreq <- TermDocumentMatrix(descriptionsList) 
termFreq <- as.data.frame(as.matrix(termFreq))
termFreq <- termFreq %>%
  mutate(angle = 90 * sample(c(0, 1), n(), replace = TRUE, prob = c(70, 30)))
clusterNames <- lessR::to ("cluster", from = 1, until = 36)
colnames(termFreq) <- c(clusterNames, "angle")
termFreq$expression <- rownames(termFreq)
myColor <- colorRampPalette(c("#000099", "#990000"))(nrow(termFreq))

#### I can not manage with a loop unfortunately
set.seed(1234)
p1 <- ggplot(termFreq, aes(label = expression, size = cluster01, angle = angle, color = expression)) +
  geom_text_wordcloud(area_corr = TRUE, area_corr_power = 1.05, eccentricity = 0.4, grid_margin = 0.3) + 
  scale_size_area(max_size = 9) +
  theme_minimal() + 
  scale_color_manual(values = myColor)
p2 <- ggplot(termFreq, aes(label = expression, size = cluster02, angle = angle, color = expression)) +
  geom_text_wordcloud(area_corr = TRUE, area_corr_power = 1.05, eccentricity = 0.4, grid_margin = 0.3) + 
  scale_size_area(max_size = 9) +
  theme_minimal() + 
  scale_color_manual(values = myColor)
p3 <- ggplot(termFreq, aes(label = expression, size = cluster03, angle = angle, color = expression)) +
  geom_text_wordcloud(area_corr = TRUE, area_corr_power = 1.05, eccentricity = 0.4, grid_margin = 0.3) + 
  scale_size_area(max_size = 9) +
  theme_minimal() + 
  scale_color_manual(values = myColor)
p4 <- ggplot(termFreq, aes(label = expression, size = cluster04, angle = angle, color = expression)) +
  geom_text_wordcloud(area_corr = TRUE, area_corr_power = 1.05, eccentricity = 0.4, grid_margin = 0.3) + 
  scale_size_area(max_size = 9) +
  theme_minimal() + 
  scale_color_manual(values = myColor)
p5 <- ggplot(termFreq, aes(label = expression, size = cluster05, angle = angle, color = expression)) +
  geom_text_wordcloud(area_corr = TRUE, area_corr_power = 1.05, eccentricity = 0.4, grid_margin = 0.3) + 
  scale_size_area(max_size = 9) +
  theme_minimal() + 
  scale_color_manual(values = myColor)
p6 <- ggplot(termFreq, aes(label = expression, size = cluster06, angle = angle, color = expression)) +
  geom_text_wordcloud(area_corr = TRUE, area_corr_power = 1.05, eccentricity = 0.4, grid_margin = 0.3) + 
  scale_size_area(max_size = 9) +
  theme_minimal() + 
  scale_color_manual(values = myColor)

pltWc <- plot_grid(p1, p2, p3, p4, p5, p6, labels = clusterNames[1:6], ncol = 2, nrow = 3)
plot_grid(pltNetwk, pltWc, ncol = 2, nrow = 1)
```
<pre>



</pre>
### The top 200 lowest GO's in a Network graph clustered to GO categories
```{r networkGOToCategory}
x <- enrichplot::pairwise_termsim(ensembl_raw_salmon_gsea, method = "JC")
enrichplot::emapplot(
    x,
    showCategory = 200,
    repel = TRUE,
    color = "NES",
    cluster.params = list(cluster = TRUE, legend = TRUE),
    node_label = "none"
)
## NO COMPRENDE: why can I not show all the GO's ?????? it says out of bound
## how exactly does it categorize the GO terms??
```
<pre>



</pre> 
### GO plot showing the significant points in GO hierarchy
```{r GoHierarchySignificance, warning = FALSE}
## in goplot showCategory seems to relate to GO hierarchy
enrichplot::goplot(
    ensembl_raw_salmon_gsea,
    showCategory = 5,
    repel = TRUE
)
# NO COMPRENDE: showCategories does what
```
<pre>



</pre>
## Session info
```{r sessionInfo}
sessionInfo()
```


```
